# Morse Code Learning Game
[morse-code-home-screen.png](home-screen)
The GPIO interrupt was responsible for multiple things, upon the falling edge of the GPIO signal (upon the press-down of the GPIO21 button) the current time of this action was taken from the TimeLR register and stored in a temporary memory location (down_time variable), this action also disabled any pending alarms (this is important and explained later). Upon the release of the GPIO21 button, the rising edge of the signal triggers the gpio isr yet again, this time however, activating a different subroutine, which took the current time of the action from the TimeLR register, and compared it to the original “down time” stored in the down_time variable. From this, the program could judge whether the press was a dot or a dash in morse, comparing the duration of the press to a threshold defined as approximately 0.19seconds (under this threshold, presses are registered as dots, otherwise they are registered as dashes). The letting go of the button also set and enabled two alarms, ALARM0 and ALARM1, to 1.5seconds and 3seconds respectively. These two alarms are responsible for establishing the gap between characters in morse (for example, .- …, A S) and registering the end of a sequence, respectively again. Upon the end of a sequence, the user input was submitted for review inside of a C function called the ‘state processor’. Each of these subroutines utilized the valuable lesson of calling C functions from within Assembly, as taught in Assignment 1 (using the printf function from within assembly).  

Each input could then be compared and verified within the C code, for example the ‘add_dot’ and ‘add_dash’ functions, which would automatically print the input of the user, and add these characters to the input buffer. Upon the ‘end_sequence’ or ALARM1 timeout, the input buffer was collected and placed inside the state_processor function for further inspection, where for example, if the input was verified to be a number between 1 and 4, and the player was currently on the Level Selection screen, the input was used to set the level of the game, and to enter a game state. In other cases, the input was used to check for in-game input for example, checking whether a word entered by the player was indeed correct. 

For peripheral control, functions such as put_pixel() and urgb_u32() control the LED outputs, causing them to change colors in response to game events. The game logic is organized around initializing the game, processing input from GPIO button presses, and converting Morse code inputs to alphanumeric characters using a predefined lookup table. 

This setup supports multiple difficulty levels, and the game's flow is controlled by functions that handle various game states, transitions, and player interactions such as correct or incorrect inputs, level progression, or game termination. 